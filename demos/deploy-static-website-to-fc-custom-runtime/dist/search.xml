<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="2022/03/30/regexp/"/>
      <url>2022/03/30/regexp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\</code></td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。</td></tr><tr><td><code>^</code></td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td><code>$</code></td><td>匹配输入字符串的结束位置。如果设置了 RegExp 对象的 Multiline 属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td><code>*</code></td><td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td></tr><tr><td><code>+</code></td><td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td><code>?</code></td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td><code>&#123;n&#125;</code></td><td>n 是一个非负整数。匹配确定的 n 次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个 o。</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>n 是一个非负整数。至少匹配 n 次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有 o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>m 和 n 均为非负整数，其中 n&lt;=m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}”将匹配“fooooood”中的前三个 o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td><code>?</code></td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td></tr><tr><td><code>.</code></td><td>匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.&#124;\n)”的模式。</td></tr><tr><td><code>(pattern)</code></td><td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript 中则使用$0…$9 属性。要匹配圆括号字符，请使用“(”或“)”。</td></tr><tr><td><code>(?:pattern)</code></td><td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(&#124;)”来组合一个模式的各个部分是很有用。例如“industr(?:y&#124;ies)”就是一个比“industry&#124;industries”更简略的表达式。</td></tr><tr><td><code>(?=pattern)</code></td><td>正向肯定预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95&#124;98 &#124;NT&#124;2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td><code>(?!pattern)</code></td><td>正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95&#124;98&#124;NT&#124;2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td><p style="width: 140px"><code>(?&lt;=pattern)</code></p></td><td>反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95&#124;98&#124;NT&#124;2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td><code>(?&lt;!pattern)</code></td><td>反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95&#124;98&#124;NT&#124;2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</td></tr><tr><td><code>x&amp;#124;y</code></td><td>匹配 x 或 y。例如，“z&#124;food”能匹配“z”或“food”。“(z&#124;f)ood”则匹配“zood”或“food”。</td></tr><tr><td><code>[xyz]</code></td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td><code>[^xyz]</code></td><td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。</td></tr><tr><td><code>[a-z]</code></td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td></tr><tr><td><code>[^a-z]</code></td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td><code>\b</code></td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td><code>\B</code></td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td><code>\cx</code></td><td>匹配由 x 指明的控制字符。例如，\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的“c”字符。</td></tr><tr><td><code>\d</code></td><td>匹配一个数字字符。等价于[0-9]。</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符。等价于[^0-9]。</td></tr><tr><td><code>\f</code></td><td>匹配一个换页符。等价于\x0c 和\cL。</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符。等价于\x0a 和\cJ。</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符。等价于\x0d 和\cM。</td></tr><tr><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td><code>\t</code></td><td>匹配一个制表符。等价于\x09 和\cI。</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符。等价于\x0b 和\cK。</td></tr><tr><td><code>\w</code></td><td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</td></tr><tr><td><code>\W </code></td><td>匹配任何非单词字符。等价于“[^a-za-z0-9_]”。</td></tr><tr><td><code>\xn</code></td><td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td><code>\num</code></td><td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td></tr><tr><td><code>\n</code></td><td>标识一个八进制转义值或一个向后引用。如果\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字（0-7），则 n 为一个八进制转义值。</td></tr><tr><td><code>\nm</code></td><td>标识一个八进制转义值或一个向后引用。如果\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字（0-7），则\nm 将匹配八进制转义值 nm。</td></tr><tr><td><code>\nml</code></td><td>如果 n 为八进制数字（0-3），且 m 和 l 均为八进制数字（0-7），则匹配八进制转义值 nml。</td></tr><tr><td><code>\un</code></td><td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如，\u00A9 匹配版权符号（©）。</td></tr></tbody></table><h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>用户名</td><td><code>/^([a-zA-Z][-a-z0-9A-Z]&#123;0,64&#125;)$/</code> // 必须以字母开头，可含数字、字母（大小写敏感）、连字符组成，0-64 位字符。</td></tr><tr><td>密码</td><td><code>/^[a-z0-9_-]&#123;6,18&#125;$/</code></td></tr><tr><td>十六进制值</td><td><code>/^#?([a-f0-9]&#123;6&#125;&#124;[a-f0-9]&#123;3&#125;)$/</code></td></tr><tr><td>电子邮箱</td><td><code>/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)\$/</code> <br> <code>/^[a-z\d]+(\.[a-z\d]+)\_@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/</code></td></tr><tr><td>URL</td><td><code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]_)_\/?$/</code></td></tr><tr><td>IP 地址</td><td><code>/((2[0-4]\d&#124;25[0-5]&#124;[01]?\d\d?).)&#123;3&#125;(2[0-4]\d&#124;25[0-5]&#124;[01]?\d\d?)/</code> <br> <code>/^(?:(?:25[0-5]&#124;2[0-4][0-9]&#124;[01]?[0-9][0-9]?).)&#123;3&#125;(?:25[0-5]&#124;2[0-4][0-9]&#124;[01]?[0-9][0-9]?)$/</code></td></tr><tr><td>HTML 标签</td><td><code>/^<([a-z]+)([^<]+)<em>(?:>(.</em>)</\1>&#124;\s+/>)$/</code></td></tr><tr><td>删除代码 \\注释</td><td><code>(?&lt;!http:&#124;\S)//.*$</code></td></tr><tr><td>Unicode 编码中的汉字范围</td><td><code>/^[\u2E80-\u9FFF]+$/</code></td></tr><tr><td>git 仓库</td><td><code>/(?&lt;=\/)[^\/]+(?=\.git)/</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 @serverless-devs/s 部署静态网站到阿里云函数计算FC</title>
      <link href="2022/03/16/serverless-devs/"/>
      <url>2022/03/16/serverless-devs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>托管静态网站的云服务，目前市面上还是挺多的，可以参见之前的文章<a href="/2021/04/26/deploy/">【静态网站托管服务】</a>。<br>适用类型：</p><ul><li>如果你是一个后端开发者</li><li>如果你是一个前端开发者</li><li>如果你是一个接单小能手</li><li>如果你是一个创业公司</li></ul><p>在对比了几款不同的云产品之后，决定使用阿里云的函数计算来托管构建出来的静态网站 FC。函数计算每月前 100 万次的免费函数调用额度，以及弹性实例自带的 <a href="https://help.aliyun.com/document_detail/51907.html">500 Mb 存储空间</a>对于大多数开发者而已，基本够用了，一般不会产生额外费用。</p><h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><p>假设我们现在有如下结构的前端工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">├ dist&#x2F; 待部署的构建产物</span><br><span class="line">│  └ index.html</span><br><span class="line">├ src&#x2F;</span><br><span class="line">└ package.json</span><br></pre></td></tr></table></figure><h2 id="编写一个简单的-HTTP-服务器"><a href="#编写一个简单的-HTTP-服务器" class="headerlink" title="编写一个简单的 HTTP 服务器"></a>编写一个简单的 HTTP 服务器</h2><p>// app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const express &#x3D; require(&quot;express&quot;);</span><br><span class="line">const app &#x3D; new express();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 dist 文件夹中的内容对外提供静态文件访问</span><br><span class="line">app.use(express.static(&#39;dist&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重定向无法处理的请求到网站的根目录</span><br><span class="line">app.use((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.redirect(&quot;&#x2F;&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听 FC custom 运行时默认的 9000 端口</span><br><span class="line">const port &#x3D; 9000;</span><br><span class="line">app.listen(port, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;App started on port $&#123;port&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 node app.js 启动这个简单的 Express 服务器, 并访问 <a href="http://localhost:9000/">http://localhost:9000</a> 确认 /dist/index.html 能被访问到.</p><p>接下来就是把 app.js 和 dist 一起发布到函数计算上就行了</p><h1 id="部署静态网站到-Custom-Runtime-函数"><a href="#部署静态网站到-Custom-Runtime-函数" class="headerlink" title="部署静态网站到 Custom Runtime 函数"></a>部署静态网站到 Custom Runtime 函数</h1>]]></content>
      
      
      <categories>
          
          <category> Serverless </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> serverless-devs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Github Webhooks 做网站的自动化部署</title>
      <link href="2021/08/12/github-webhooks/"/>
      <url>2021/08/12/github-webhooks/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://docs.github.com/cn/developers/webhooks-and-events/webhooks/about-webhooks">Github Webhooks</a> 允许我们构建或设置集成，以订阅 <a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads">GitHub.com</a> 上的某些事件。 当触发其中某个事件时，将向 Webhooks 配置 Paloyd URL 发送 HTTP POST 请求。可用于更新外部议题跟踪器、触发 CI 构建、更新备份镜像，甚至部署到生产服务器。</p></blockquote><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul><li>个人博客<br>如： 代码提交远程仓库 =&gt; 触发 Github Webhooks =&gt; 服务器触发器监听 =&gt; 同步更新博客</li></ul><p>因本文重点在介绍 <code>webhooks</code> 的自动化功能，我们在此场景的基础上，简化一下步骤，将<code>远程服务器</code>改为<code>本地服务器</code>。<br>如：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代码提交远程仓库 -&gt; 触发 Github Webhooks -&gt; <u>本地服务触发器监听</u> -&gt; 拉取最新代码</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="配置-Shell-脚本"><a href="#配置-Shell-脚本" class="headerlink" title="配置 Shell 脚本"></a>配置 Shell 脚本</h3><ul><li>创建 blog_deploy.sh 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">LOG_FILE&#x3D;&quot;&#x2F;Users&#x2F;huangfushan&#x2F;project&#x2F;code&#x2F;blog_deploy.log&quot;</span><br><span class="line"></span><br><span class="line">date &gt;&gt; &quot;$LOG_FILE&quot;</span><br><span class="line">echo &quot;Start deployment&quot; &gt;&gt;&quot;$LOG_FILE&quot;</span><br><span class="line">echo &quot;pulling source code...&quot; &gt;&gt; &quot;$LOG_FILE&quot;</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;huangfushan&#x2F;github-webhooks.git &#x2F;Users&#x2F;huangfushan&#x2F;project&#x2F;code&#x2F;huangfushan.github.io</span><br><span class="line">echo &quot;Finished.&quot; &gt;&gt;&quot;$LOG_FILE&quot;</span><br><span class="line">echo &gt;&gt; $LOG_FILE</span><br></pre></td></tr></table></figure><p>大致意思是，当接收到请求时，会在本地指定目录下，拉取一份最新代码，模拟“服务器同步更新博客”的效果。</p><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><ul><li>创建 index.js 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line"></span><br><span class="line">const run_cmd &#x3D; (cmd, args, callback) &#x3D;&gt; &#123;</span><br><span class="line">  var spawn &#x3D; require(&#39;child_process&#39;).spawn;</span><br><span class="line">  var child &#x3D; spawn(cmd, args);</span><br><span class="line">  var resp &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">  child.stdout.on(&#39;data&#39;, function(buffer) &#123; resp +&#x3D; buffer.toString(); &#125;);</span><br><span class="line">  child.stdout.on(&#39;end&#39;, function() &#123; callback(resp) &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res) &#123;</span><br><span class="line">  if (req.url &#x3D;&#x3D;&#x3D; &#39;&#x2F;webhooks&#39;) &#123;</span><br><span class="line">    console.log(&#39;监听到接口请求&#39;);</span><br><span class="line">    run_cmd(&#39;sh&#39;, [&#39;.&#x2F;blog_deploy.sh&#39;], () &#x3D;&gt; console.log(1, &#39;run sucess&#39;));</span><br><span class="line">  &#125;</span><br><span class="line">  res.statusCode &#x3D; 200;</span><br><span class="line">  res.end(&#39;hello world&#39;);</span><br><span class="line">&#125;).listen(8080)</span><br><span class="line"></span><br><span class="line">console.log(&#39;http:&#x2F;&#x2F;localhost:8080&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上代码，当 HTTP 请求接口为 <code>/webhooks</code> 时，执行同步资源操作。当然，这里仅仅是一个例子，实际场景中需要校验 <code>Method</code>，<code>请求体</code>，<code>Secret 签名</code> 等信息</p><ul><li>执行代码，启动端口为 8080 的本地服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br></pre></td></tr></table></figure><!-- - 当服务接收到来自 http://localhost:8080/webhooks 的请求时，拉取远程最新代码。 --><ul><li>通过 <code>ngrok</code> 实现内网穿透服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install ngrok -g</span><br><span class="line">ngrok http localhost:8080</span><br></pre></td></tr></table></figure><p><img src="https://hfscdn.vercel.app/blog/image/ngrok.jpg" alt="img"></p><p>如上图，本地 <code>localhost:8080</code> 指向了 <code>http://8ffcaa193540.ngrok.io</code>，这么做的目前是为了向互联网暴露本地主机，支持外网访问，也为了下一步 Webhooks 的配置使用，。</p><p>当然，除了<code>ngrok</code>，也可以通过 <code>nginx</code> 将 当前服务反向代理到指定外网地址的 80 端口。</p><h3 id="配置-Github-Webhooks"><a href="#配置-Github-Webhooks" class="headerlink" title="配置 Github Webhooks"></a>配置 Github Webhooks</h3><ul><li><p>创建一个 Github 仓库，如 <code>github-webhooks</code>。</p></li><li><p>到 <code>github-webhooks</code> 下 Settings，配置 Github Webhooks 监听，其中</p><ul><li><p><code>Payload URL</code>：用来接收请求接口，github 接收到 Repo 的操作指令时，会往这个接口发送一个带有描述操作内容的 Post 请求。这里，我们填写第二步暴露的外网地址，如 <code>http://8ffcaa193540.ngrok.io/webhooks</code>，实际效果 Github 将往本地 8080 端口服务发送一个接口为 <code>/webhooks</code> 的 HTTP 请求。</p></li><li><p><code>Content Type</code>：两种传参方式，application/json 和 application/x-www-form-urlencoded</p></li><li><p><code>Secret</code>：令牌校验，加上这个字段之后，来自 Github 的请求 HTTP 请求头会携带 X-Hub-Signature 的加密签名，防止其他恶意请求触发。</p></li></ul></li></ul><p><img src="https://hfscdn.vercel.app/blog/image/dk-github-webhooks.png" alt="img"></p><p><img src="https://hfscdn.vercel.app/blog/image/github-webhooks-add.jpg" alt="img"></p><h3 id="触发-Github-Webhooks"><a href="#触发-Github-Webhooks" class="headerlink" title="触发 Github Webhooks"></a>触发 Github Webhooks</h3><ul><li>往 <code>github-webhooks</code> 远程仓库提交一个 <code>commit</code>，查看是否在本地触发执行 shell 脚本</li><li>查看 Recent Deliverles 日志</li></ul><p><img src="https://hfscdn.vercel.app/blog/image/github-webhooks-trigger.jpg" alt="img"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><blockquote><p>搭建本地服务器那一步，部分网友使用 <code>github-webhook-handler</code> 插件，来处理 Github 发送过来的 HTTP 请求，并监听各类事件，如 <code>push</code>, <code>issues</code>等。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;)</span><br><span class="line">var createHandler &#x3D; require(&#39;github-webhook-handler&#39;)</span><br><span class="line">var handler &#x3D; createHandler(&#123; path: &#39;&#x2F;webhooks&#39;, secret: &#39;myHashSecret&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 上面的 secret 保持和 GitHub 后台设置的一致</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">  handler(req, res, function (err) &#123;</span><br><span class="line">    res.statusCode &#x3D; 404</span><br><span class="line">    res.end(&#39;no such location&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).listen(8080)</span><br><span class="line"></span><br><span class="line">handler.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">  console.error(&#39;发生错误:&#39;, err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">handler.on(&#39;push&#39;, function (event) &#123;</span><br><span class="line">  console.log(&#39;接收到push请求&#39;）</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样也是很方便的，该插件已经帮我们处理了，<code>path</code>，<code>method</code>，<code>Secret 令牌签名</code>等等校验，并针对 Github 各种事件监听。但是美中不足的是，该插件不支持 <code>application/x-www-form-urlencoded</code> 的请求方式，仅支持 JSON 格式。</p><p>后续我会另找时间，争取解决上诉插件存在的问题。</p><p>github 更多事件，见 <a href="https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads">Webhooks events &amp; Payloads</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（AST）抽象语法数 -- babel 插件</title>
      <link href="2021/08/10/babel/"/>
      <url>2021/08/10/babel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p> <code>babel</code>是 <code>Javascript</code> 的编译语法器，确切来说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）。意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。</p><h2 id="抽象语法数（AST）"><a href="#抽象语法数（AST）" class="headerlink" title="抽象语法数（AST）"></a>抽象语法数（AST）</h2><p>这个处理过程中的每一步都涉及到创建或是操作抽象语法树，亦称 AST。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function square(n) &#123;</span><br><span class="line">  return n * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序可以被表示成如下的一棵树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- FunctionDeclaration:</span><br><span class="line">  - id:</span><br><span class="line">    - Identifier:</span><br><span class="line">      - name: square</span><br><span class="line">  - params [1]</span><br><span class="line">    - Identifier</span><br><span class="line">      - name: n</span><br><span class="line">  - body:</span><br><span class="line">    - BlockStatement</span><br><span class="line">      - body [1]</span><br><span class="line">        - ReturnStatement</span><br><span class="line">          - argument</span><br><span class="line">            - BinaryExpression</span><br><span class="line">              - operator: *</span><br><span class="line">              - left</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br><span class="line">              - right</span><br><span class="line">                - Identifier</span><br><span class="line">                  - name: n</span><br></pre></td></tr></table></figure><p>或是如下所示的 JavaScript Object（对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;FunctionDeclaration&quot;,</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;square&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  params: [&#123;</span><br><span class="line">    type: &quot;Identifier&quot;,</span><br><span class="line">    name: &quot;n&quot;</span><br><span class="line">  &#125;],</span><br><span class="line">  body: &#123;</span><br><span class="line">    type: &quot;BlockStatement&quot;,</span><br><span class="line">    body: [&#123;</span><br><span class="line">      type: &quot;ReturnStatement&quot;,</span><br><span class="line">      argument: &#123;</span><br><span class="line">        type: &quot;BinaryExpression&quot;,</span><br><span class="line">        operator: &quot;*&quot;,</span><br><span class="line">        left: &#123;</span><br><span class="line">          type: &quot;Identifier&quot;,</span><br><span class="line">          name: &quot;n&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        right: &#123;</span><br><span class="line">          type: &quot;Identifier&quot;,</span><br><span class="line">          name: &quot;n&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会留意到 AST 的每一层都拥有相同的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;FunctionDeclaration&quot;,</span><br><span class="line">  id: &#123;...&#125;,</span><br><span class="line">  params: [...],</span><br><span class="line">  body: &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &quot;Identifier&quot;,</span><br><span class="line">  name: ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: &quot;BinaryExpression&quot;,</span><br><span class="line">  operator: ...,</span><br><span class="line">  left: &#123;...&#125;,</span><br><span class="line">  right: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：出于简化的目的移除了某些属性</p></blockquote><p>这样的每一层结构也被叫做 节点（Node）。 一个 AST 可以由单一的节点或是成百上千个节点构成。</p><h2 id="Babel-的处理步骤"><a href="#Babel-的处理步骤" class="headerlink" title="Babel 的处理步骤"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是： <strong>解析（parse）</strong>，<strong>转换（transform）</strong>，<strong>生成（generate）</strong>。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：**词法分析（Lexical Analysis） **和 语法分析（Syntactic Analysis）。</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。<br>你可以把令牌看作是一个扁平的语法片段数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * n;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 0, end: 1, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;*&quot;, start: 2, end: 3, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; type: &#123; ... &#125;, value: &quot;n&quot;, start: 4, end: 5, loc: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>每一个 type 有一组属性来描述该令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &#123;</span><br><span class="line">    label: &#39;name&#39;,</span><br><span class="line">    keyword: undefined,</span><br><span class="line">    beforeExpr: false,</span><br><span class="line">    startsExpr: true,</span><br><span class="line">    rightAssociative: false,</span><br><span class="line">    isLoop: false,</span><br><span class="line">    isAssign: false,</span><br><span class="line">    prefix: false,</span><br><span class="line">    postfix: false,</span><br><span class="line">    binop: null,</span><br><span class="line">    updateContext: null</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 AST 节点一样它们也有 start，end，loc 属性。</p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。</p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>转换步骤接收 AST 并对其遍历，在此过程对节点进行添加、更新、删除等操作。这个是 Babel 编译器 中最复杂的过程，也是插件将来要介入工作的部分。</p><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>代码生成步骤把最终（经过一系列转换后）的 AST 转成字符串形式的代码，同时还会创建 <a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">源码映射</a><br>代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>想要转换 AST 你需要进行递归的树形遍历。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 commitizen 规范 git commit 提交说明</title>
      <link href="2021/06/09/commitizen/"/>
      <url>2021/06/09/commitizen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Git 作为目前开源社区最为火热的分布式系统版本管理工具，当我们在提交代码之前，都是需要添加 <code>Commit message</code>（提交说明），否则就不允许提交。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>上面代码的 <code>-m</code> 参数，就是用来指定 <code>commit message</code>的。</p><p>如果一行不够，可以只执行 <code>git commit</code>，就会跳出文本编辑器，让你写多行。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit</span><br></pre></td></tr></table></figure><p>基本上，你写什么都行。<br><img src="https://hfscdn.vercel.app/blog/image/commitizen-0.png" alt="iamge"></p><p>我们先来看下平时提交的 <code>commmit</code> 日志，只是简单的说明本次提交的信息，如<br><img src="https://hfscdn.vercel.app/blog/image/commitizen-1.png" alt="iamge"></p><p>我们再来看下具有一定规范性的 <code>commit</code> 日志，是不是更加清晰明了，有了一定的规范，对提交类型做了区分。<br><img src="https://hfscdn.vercel.app/blog/image/commitizen-2.png" alt="image"></p><p>一般来说，<code>commit message</code> 应该清晰明了，说明本次提交的目的。</p><p>目前，社区有多种 Commit message 的写法规范。这种是 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>，<a href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">中文</a>。这是目前使用最广的写法，是比较合理和系统化，并且有配套的工具。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><ul><li>提供更多的历史信息，方便快速浏览。</li><li>可以过滤某些 <code>commit</code>（比如文档改动），便于快速查找信息。</li><li>可以直接从 <code>commit</code> 生成 <code>Change log</code>。</li></ul><h2 id="标准-Commit-Message-规范"><a href="#标准-Commit-Message-规范" class="headerlink" title="标准 Commit Message 规范"></a>标准 Commit Message 规范</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>每次提交可以包含页眉(<code>header</code>)、正文(<code>body</code>)和页脚(<code>footer</code>)。其中，<code>Header</code> 是必需的。</p><p>每次提交的信息不超过 <code>100</code> 个字符，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">commit f477xxxxxxxba558 (HEAD -&gt; master)</span><br><span class="line">Author: huangfushan &lt;xxxxxxxxx@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 4 15:48:29 2021 +0800</span><br><span class="line"></span><br><span class="line">    feat: 🎸 添加新功能</span><br><span class="line">    </span><br><span class="line">    新功能详情介绍</span><br><span class="line">    </span><br><span class="line">    BREAKING CHANGE: 🧨 footer</span><br></pre></td></tr></table></figure><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p> <code>Header</code> 部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和 <code>subject</code>（必需）。</p><ul><li><code>type</code> 用于说明 <code>commit</code> 的类别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git cz</span><br><span class="line">? Select the type of change that you&#39;re committing: (Use arrow keys or type to search)</span><br><span class="line">❯ 💍  test:       Adding missing tests                                    &#x2F;&#x2F; 添加缺失的测试</span><br><span class="line">  🎸  feat:       A new feature                                           &#x2F;&#x2F; 新功能（feature）</span><br><span class="line">  🐛  fix:        A bug fix                                               &#x2F;&#x2F; bug 修复</span><br><span class="line">  🤖  chore:      Build process or auxiliary tool changes                 &#x2F;&#x2F; 构建过程或辅助工具更改</span><br><span class="line">  ✏️  docs:       Documentation only changes                              &#x2F;&#x2F; 文档</span><br><span class="line">  💡  refactor:   A code change that neither fixes a bug or adds a feature&#x2F;&#x2F; 重构（不修复错误,不添加功能的代码更改）</span><br><span class="line">  💄  style:      Markup, white-space, formatting, missing semi-colons... &#x2F;&#x2F; 标记、空格、格式、缺少分号</span><br><span class="line">  🎡  ci:         CI related changes                                      &#x2F;&#x2F; CI相关的变化</span><br><span class="line">  ⚡️  perf:       A code change that improves performance                 &#x2F;&#x2F; 提高性能的代码更改</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><code>scope</code>，用于说明 <code>commit</code> 影响的范围</li><li><code>subject</code> 是 commit 目的的简短描述，一般不超过50个字符。</li></ul><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p><code>Body</code> 部分是对本次 commit 的详细描述，可以分成多行</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p><code>Footer</code> 部分只用于两种情况。</p><ul><li>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述</li><li>关闭 <code>Issue</code><br>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 单个</span><br><span class="line">Closes #123</span><br><span class="line">&#x2F;&#x2F; 支持多个</span><br><span class="line">Closes #123, #245, #992</span><br></pre></td></tr></table></figure></li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>上诉 <code>commit</code> 规范看起来是不很麻烦，这里推荐使用一些开源的工具进行管理，我们先来看一下效果<br><img src="https://hfscdn.vercel.app/blog/image/commitizen-3.gif" alt="image"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><h4 id="commitizen-–-自动生成合格的-commit-message"><a href="#commitizen-–-自动生成合格的-commit-message" class="headerlink" title="commitizen – 自动生成合格的 commit message"></a><code>commitizen</code> – 自动生成合格的 <code>commit message</code></h4><p><code>commitizen</code> 是一个撰写合格 <code>Commit message</code> 的工具，通过 <code>commitizen</code> 我们可以快速生成符合规范的 <code>commit message</code>，下面我们介绍下怎么在项目中使用。</p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g commitizen</span><br></pre></td></tr></table></figure></li><li><p>在项目目录里，运行下面的命令，使其支持 <code>Angular</code> 的 <code>Commit message</code> 格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ commitizen init cz-conventional-changelog --save --save-exact</span><br></pre></td></tr></table></figure><p>如果出现报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attempting to initialize using the npm package cz-conventional-changelog</span><br><span class="line">Error: A previous adapter is already configured. Use --force to override</span><br></pre></td></tr></table></figure></li></ul><p>可以在指令后面加上 –force</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><h4 id="git-cz-–-插件全局安装"><a href="#git-cz-–-插件全局安装" class="headerlink" title="git-cz – 插件全局安装"></a><code>git-cz</code> – 插件全局安装</h4><p>安装<code>git-cz</code>工具，也可用快速生成符合规范的 <code>commit message</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g git-cz</span><br><span class="line">$ git-cz</span><br></pre></td></tr></table></figure><h2 id="生成-CHANGE-LOG"><a href="#生成-CHANGE-LOG" class="headerlink" title="生成 CHANGE LOG"></a>生成 CHANGE LOG</h2><p>如果需要生成发布记录，可以通过 <code>conventional-changelog-cli</code> 生成。一般情况下，生成的文档包括</p><ul><li>New features</li><li>Bug fixes</li><li>Breaking changes.</li></ul><p>其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g conventional-changelog-cli</span><br></pre></td></tr></table></figure><h3 id="修改-package-json"><a href="#修改-package-json" class="headerlink" title="修改 package.json"></a>修改 <code>package.json</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot;,</span><br><span class="line">  &quot;changelog-all&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="生成-CHANGELOG-md"><a href="#生成-CHANGELOG-md" class="headerlink" title="生成 CHANGELOG.md"></a>生成 CHANGELOG.md</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm run changelog &#x2F;&#x2F; 不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。</span><br><span class="line">$ npm run changelog-all &#x2F;&#x2F; 生成所有发布的 Change log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 Lerna 实现多个软件包的管理</title>
      <link href="2021/06/02/lerna/"/>
      <url>2021/06/02/lerna/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>将大型代码仓库分割成多个独立版本化的软件包（package）对于代码共享来说非常有用。但是，如果某些更改 跨越了多个代码仓库的话将变得很 麻烦 并且难以跟踪，并且跨越多个代码仓库的测试将迅速变得非常复杂。<br>为了解决这些（以及许多其它）问题，某些项目会将 代码仓库分割成多个软件包（package），并将每个软件包存放到独立的代码仓库中。</p></blockquote><p><code>Lerna</code> 是一种工具，针对 使用 <code>git</code> 和 <code>npm</code> 管理多软件包代码仓库的工作流程进行优化。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --global lerna                    &#x2F;&#x2F; 全局安装 lerna</span><br><span class="line">git init hfs-lerna-test &amp;&amp; cd hfs-lerna-test  &#x2F;&#x2F; 创建文件夹， hfs-lerna-test 仅代表当前例子文件夹名</span><br><span class="line">lerna init                                    &#x2F;&#x2F; 初始化一个lerna项目结构，如果希望各个包使用单独版本号可以加 -i | --independent</span><br></pre></td></tr></table></figure><p>你的代码仓库目前应该是如下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- hfs-lerna-test&#x2F;</span><br><span class="line">  - packages&#x2F;</span><br><span class="line">  - package.json</span><br><span class="line">  - lerna.json</span><br></pre></td></tr></table></figure><h2 id="运作方式"><a href="#运作方式" class="headerlink" title="运作方式"></a>运作方式</h2><h3 id="Fixed-模式（默认）"><a href="#Fixed-模式（默认）" class="headerlink" title="Fixed 模式（默认）"></a>Fixed 模式（默认）</h3><p>固定模式，也就是我们初始化时默认采用的模式。该模式为单版本号，在根目录 <code>lerna.json</code> 中设置，该模式你可以理解为 ‘全量发布’，即任何一个模块更新了，当你在执行 <code>lerna publish</code> 发布时，所有的模块都会统一更新版本号。<code>Babel</code> 目前就是采用该模式。</p><h3 id="Independent-模式"><a href="#Independent-模式" class="headerlink" title="Independent 模式"></a>Independent 模式</h3><p><code>lerna init --independent</code></p><p>独立模式的 Lerna 项目允许维护者单独升级包版本，可以理解为’增量发布’。每次发布时，您都会收到有关已更改的每个包的提示，以指定它是补丁、次要、主要还是自定义更改。  </p><p>这种方式相对第一种来说，更灵活，只需将只需将 <code>lerna.json </code> 中的 <code>version</code> 键改成 <code>independent</code> 即可启用 <code>independent</code> 模式。</p><h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p><code>lerna create test-1</code><br><code>lerna create test-2</code></p><p>执行上面的命令后会在 <code>packages</code> 中创建对应的模块，并根据提示生成 <code>package.json</code></p><p><img src="https://hfscdn.vercel.app/blog/image/lerna-create.png" alt="hexo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── lerna.json</span><br><span class="line">├── package.json</span><br><span class="line">└── packages</span><br><span class="line">    └── test-1</span><br><span class="line">    ├── __tests__</span><br><span class="line">    │    └── test-1.test.js</span><br><span class="line">    ├── lib</span><br><span class="line">    │    └── test-1.js</span><br><span class="line">        ├── package.json</span><br><span class="line">        └── README.md</span><br><span class="line">    └── test-2</span><br><span class="line">    ├── __tests__</span><br><span class="line">    │    └── test-2.test.js</span><br><span class="line">    ├── lib</span><br><span class="line">    │    └── test-2.js</span><br><span class="line">        ├── package.json</span><br><span class="line">        └── README.md</span><br></pre></td></tr></table></figure><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><blockquote><ul><li>我们时常看到某些一类诸如 <code>@babel/runtime</code>、<code>@babel/preset-env</code>的依赖包，其中 <code>babel</code> 实际就是可以看成包组织作用域的意思，代指分将<code>babel</code>包分割成多个独立版本化的软件包（package）。</li><li><code>npm</code> 包前面加 <code>@</code>，代表 <code>scopes</code> 相关的包，可以理解为作用域(范围)包， <code>npm</code> 作用域的命名不是谁便就能用的，只有两种可以使用：自己的用户名、自己创建的组织名。</li><li>因此在 <code>test-1</code>、<code>test-2</code> 中，<code>package.json</code> 的 <code>name</code> 字段分别改成 <code>@hfs-lerna-test/test-1</code>,<code>@hfs-lerna-test/test-2</code>。</li></ul></blockquote><p>在仓库根目录执行指令安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna bootstrap</span><br></pre></td></tr></table></figure><p><code>lerna bootstrap</code>，会安装当前目录下所有定义在 <code>package.json</code> 中的依赖包。相当于给 <code>packages</code> 下的每个软件包执行 <code>npm install</code></p><p>如果 <code>test-2/package.json</code> 中引用了<code>test-1</code>的依赖，执行后将自动将其添加到依赖包中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;@hfs-lerna-test&#x2F;test-1&quot;: &quot;0.0.1&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">└── test-2</span><br><span class="line">    ├── __tests__</span><br><span class="line">    │    └── test-2.test.js</span><br><span class="line">    ├── node_modules</span><br><span class="line">    │    └── @hfs-lerna-test&#x2F;test-1</span><br><span class="line">    ├── lib</span><br><span class="line">    │    └── test-2.js</span><br><span class="line">    ├── package.json</span><br><span class="line">    └── README.md</span><br></pre></td></tr></table></figure><h2 id="发布模块"><a href="#发布模块" class="headerlink" title="发布模块"></a>发布模块</h2><p><code>lerna publish</code></p><blockquote><ul><li>执行时会打 <code>Tag</code>，上传 <code>Github </code>,上传 <code>NPM</code>。</li><li>当我们执行 <code>lerna publish</code> 命令时，可能会报错，<code>lerna publish</code> 常见错误见 <a href="#lerna-publish-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B">常见错误类型</a></li></ul></blockquote><ul><li><code>lerna publish</code> 本质上还是执行 <code>npm publish</code>，那么我们首先需要在 <code>npm</code> 仓库上注册用户，以及推送代码到远程 <code>github</code> 仓库。</li></ul><p><img src="https://hfscdn.vercel.app/blog/image/lerna-publish.png" alt="hexo"></p><ul><li><p>注意</p><ul><li><p><code>npm publish</code> 默认发布私有包，想要发布公共包必须使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish --acsess&#x3D;public</span><br></pre></td></tr></table></figure></li><li><p>复制代码也可以在 <code>packages</code> 下的每个软件包的 <code>package.json</code> 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;publishConfig&quot;: &#123;</span><br><span class="line">    &quot;access&quot;: &quot;public&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="推动远程"><a href="#推动远程" class="headerlink" title="推动远程"></a>推动远程</h3><ul><li>登录 <a href="https://github.com/">Github</a></li><li>创建代码仓库，如：<code>git@github.com:&lt;username&gt;/hfs-lerna-test.git</code></li><li>提交代码，推送到指定远程仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:&lt;username&gt;&#x2F;hfs-lerna-test.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure></li></ul><h3 id="登录-npm-账户"><a href="#登录-npm-账户" class="headerlink" title="登录 npm 账户"></a>登录 npm 账户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否登录</span><br><span class="line">npm whoami</span><br><span class="line"></span><br><span class="line"># 没有则登录 </span><br><span class="line">npm login</span><br><span class="line"></span><br><span class="line"># 输入 username password</span><br></pre></td></tr></table></figure><h3 id="【发布】使用非组织包方式"><a href="#【发布】使用非组织包方式" class="headerlink" title="【发布】使用非组织包方式"></a>【发布】使用非组织包方式</h3><p>使用非组织包方式，需要设置报名为当前 <code>npm</code> 账户名为前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm adduser</span><br><span class="line">Username: @hfs-lerna-test &#x2F;&#x2F; 自己的username</span><br><span class="line">Password:                 &#x2F;&#x2F; 密码</span><br></pre></td></tr></table></figure><h3 id="【发布】组织包-scope-packages-方式（推荐）"><a href="#【发布】组织包-scope-packages-方式（推荐）" class="headerlink" title="【发布】组织包 scope packages 方式（推荐）"></a>【发布】组织包 scope packages 方式（推荐）</h3><blockquote><p>上诉我们定义的 <code>@hfs-lerna-test</code>，即代表这里的 <code>scope</code> 为 <code>@hfs-lerna-test</code></p></blockquote><ul><li><p>在 npm 仓库中创建团队，登录 <a href="https://www.npmjs.com/">NPM</a><br><img src="https://hfscdn.vercel.app/blog/image/npm-home.png" alt="hexo"></p></li><li><p>将自己的账号添加到该团队组织中<br><img src="https://hfscdn.vercel.app/blog/image/npm-add-organization.png" alt="hexo"><br><img src="https://hfscdn.vercel.app/blog/image/npm-add-username.png" alt="hexo"></p></li><li><p>最后，可以开始愉快地 <code>lerna publish</code> 了</p></li></ul><h2 id="Lerna-更多命令"><a href="#Lerna-更多命令" class="headerlink" title="Lerna 更多命令"></a>Lerna 更多命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lerna init        &#x2F;&#x2F; 初始化</span><br><span class="line">lerna clean       &#x2F;&#x2F; 删除 node_modules</span><br><span class="line">lerna bootstrap   &#x2F;&#x2F; 安装依赖</span><br><span class="line">lerna list        &#x2F;&#x2F; 列出包名</span><br></pre></td></tr></table></figure><p><code>lerna</code> 的详细用法，请参考 <a href="https://lerna.js.org/">lerna</a>。</p><h2 id="lerna-publish-常见错误类型"><a href="#lerna-publish-常见错误类型" class="headerlink" title="lerna publish 常见错误类型"></a>lerna publish 常见错误类型</h2><p>如</p><ul><li><p>未推送远程仓库</p><blockquote><p>解决：创建 <code>Github</code> 远程仓库，绑定并推送远程。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br><span class="line">lerna ERR! ENOREMOTEBRANCH Branch &#39;master&#39; doesn&#39;t exist in remote &#39;origin&#39;.</span><br><span class="line">lerna ERR! ENOREMOTEBRANCH If this is a new branch, please make sure you push it to the remote first.</span><br></pre></td></tr></table></figure></li><li><p>401 npm 未登录</p><blockquote><p>解决：执行 <code>npm whoami</code> 查看是否 <code>NPM</code> 已登录，未登录添加账户或登录。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br><span class="line">lerna ERR! EWHOAMI Authentication error. Use &#96;npm whoami&#96; to troubleshoot.</span><br></pre></td></tr></table></figure></li><li><p>402 您必须注册私人包</p><blockquote><p>解决：当前发布的 <code>npm</code> 包是 <code>@</code> 类型为私人包，但是 <a href="https://www.npmjs.com/">NPM</a> 上不存在该包组织，或者该组织为公共包。<br>请变更包类型，或者通过共有包发布，详情见 <a href="#%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97">发布模块 - 注意</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lerna publish</span><br><span class="line">lerna ERR! E402 You must sign up for private packages</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Scope</code> 包组织未找到</p><blockquote><p>当前发布的 <code>npm</code> 包是 <code>@</code> 类型，核对 scope 是否正确，需用自己的用户名、或者自己创建的团队组织名。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna ERR! E404 Scope not found</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> lerna </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态网站托管服务</title>
      <link href="2021/05/05/deploy/"/>
      <url>2021/05/05/deploy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="/2021/04/26/blog/">上篇文章</a> 介绍了在我们不注册域名、以及购买云服务器的基础上，利用现有的免费的云厂商托管平台搭建个人网站。并以 <code>Hexo </code> + <code>Github Pages</code> 为例，实现了个人博客的快速搭建和部署。</p></blockquote><p>接下来分享其他常见的几种静态网站托管服务。</p><h1 id="云产品"><a href="#云产品" class="headerlink" title="云产品"></a>云产品</h1><h2 id="Serverless-云产品"><a href="#Serverless-云产品" class="headerlink" title="Serverless 云产品"></a>Serverless 云产品</h2><blockquote><p>通过无服务器计算，将前端静态资源快速部署到云厂商提供的云平台进行托管，配置默认生成的域名，快速生成站点。需按量付费。经测验实际费用甚微，或无。</p></blockquote><ul><li><a href="https://console.cloud.tencent.com/tcb">腾讯 Cloudbase</a></li><li><a href="https://cloud.weixin.qq.com/cloudrun/service">微信 云托管</a></li><li><a href="https://docs.serverless-devs.com/">阿里云 Devs</a></li></ul><h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><blockquote><p><a href="https://pages.github.com/">Github Pages</a> 是 <code>GitHub</code> 提供的一个网页托管服务，于 2008 年推出。可以用于存放静态网页，包括博客、项目文档甚至整本书。</p></blockquote><p>优点</p><ul><li>Github 的东家是微软，Git 管理全部代码，永远不用担心文字丢失或者复原问题；</li><li>百度无法爬取存在 Github 上的网站内容；</li><li>自带域名可 https 访问，如 https://&lt;你的 GitHub 用户名&gt;.github.io</li><li>支持自定义域名</li></ul><p>缺点</p><ul><li>无法给自定义域名配置 SSL 证书</li><li>墙内访问速度缓慢</li><li>流量限制（每个月 100Gb）基本够用</li></ul><hr><p><a href="https://docs.gitlab.com/ee/README.html">GitLab Pages</a>同样跟 GitHub Pages 的功能一样，但是：</p><ul><li>自定义域名可配置 https，不过需要上传证书</li></ul><hr><h2 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h2><blockquote><p><a href="https://vercel.com/">Vercel</a>之前也叫 <code>Zeit</code> 或 <code>now.sh</code> 是一家提供 <code>JAMStack</code>，静态网站托管的平台，支持自动从 <code>Github</code>，<code>GitLab</code>，<code>Bitbucket</code> 等仓库自动拉取代码。</p></blockquote><p>优点</p><ul><li>可以使用 CLI 上传代码，或者链接一个 Git 仓库</li><li>支持自动式构建，指定构建命令，最后把生成的静态网站的一站式服务平台</li><li>不仅提供静态网站托管，同时也支持托管 Node.js 服务</li><li>支持自定义域名且自定义域名支持一键开启 https，自动申请 SSL 证书（证书来自 Let’s Encrype）</li><li>数据通过 HTTP2 协议传输</li><li>提供 API</li></ul><hr><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><blockquote><p><a href="https://coding.net/">Coding</a> 静态网站服务是 CODING 联合腾讯云 Serverless 团队，为开发者提供的便捷、稳定、高拓展性的静态网站资源托管服务。无需自建服务器，即可一键部署网站应用，将静态网站分发至全网节点，轻松为您的网站业务增添稳定、高并发、快速访问等能力。</p></blockquote><p>优点</p><p>CODING 网站托管服务支持 Jekyll、Hexo 等多种部署框架。静态资源的分发由 腾讯云对象存储 COS 和拥有多个边缘网点的 腾讯云内容分发网络 CDN 提供支持</p><ul><li>Coding 为腾讯代理，在国内的服务器较多， 速度比 GitHub Page 快很多</li><li>支持自定义域名</li></ul><p>缺点</p><ul><li>在首次创建静态网站前，您必须先完成授权操作和实名认证</li><li>静态资源的分发由 腾讯云对象存储 COS 和拥有多个边缘网点的 腾讯云内容分发网络 CDN 提供支持，可能产生少量付费</li></ul><hr><h2 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h2><p><a href="https://www.netlify.com/">Netlify</a></p><p>优点</p><ul><li>可以使用 CLI 上传代码</li><li>支持自定义域名且自定义域名支持一键开启 https（证书来自 Let’s Encrype）</li><li>支持强制让用户通过 https 访问网站（开启后此功能后，http 的访问一律会 301 跳转到 https</li><li>支持自动构建</li><li>支持重定向（Redirects）和重写（Rewrites）功能</li><li>数据通过 HTTP2 协议传输</li><li>提供 webhooks 与 API</li></ul><p>缺点</p><ul><li>会自动把静态资源上传到 cloudfront CDN，但国内有些地方访问 cloudfront 速度很慢或部分被墙</li><li>速度比 Vercel 慢</li></ul><hr><h2 id="Bitbucket-Cloud"><a href="#Bitbucket-Cloud" class="headerlink" title="Bitbucket Cloud"></a>Bitbucket Cloud</h2><p><a href="https://support.atlassian.com/bitbucket-cloud/docs/publishing-a-website-on-bitbucket-cloud/">Bitbucket Cloud</a><br>跟 GitHub Pages 的功能一样，但是：</p><ul><li>无法自定义域名</li><li>能且只能通过 https 协议访问（http 协议会被跳转到 https 协议）</li><li>所有项目的静态网站代码都只能放在专门的站点仓库里（accountName.bitbucket.io），不能像 GitHub 那样可以在每个项目里用 gh-pages 分支保存文件</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客 Hexo + Github Page</title>
      <link href="2021/04/26/blog/"/>
      <url>2021/04/26/blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><blockquote><p>在传统认知里，搭建个人静态网站我们需要：</p></blockquote><ul><li>注册域名</li><li>购买云服务器</li><li>域名备案</li><li>构建静态网页</li><li>部署前端静态资源</li><li>DNS 解析</li></ul><blockquote><p>上诉方案作为技术小白或者初学者来说，上手较难，时间、金钱成本花费较大，不推荐。<br>我们探讨的是如何在低成本的基础上，利用市面上现有的成熟的博客框架，搭建属于我们自己的个人博客。</p></blockquote><h1 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h1><blockquote><p>为了帮助开发者快速搭建所需的网站，这里提供的几种目前市面上比较火的博客框架，可以帮助我们快速的生成所需的静态网页。</p></blockquote><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>Hexo的主题样式也有很多好看的，而且github都有star上万的。</li><li><a href="https://wordpress.org/">Wordpress</a> 是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。有着许多第三方开发的免费模板，安装方式简单易用。</li><li><a href="https://vuepress.vuejs.org/">Vuepress</a> 由两部分组成：一个以 Vue 驱动的主题系统的简约静态网站生成工具，和一个为编写技术文档而优化的默认主题。它是为了支持 Vue 子项目的文档需求而创建的。</li><li><a href="https://www.docusaurus.cn/">Docusaurus</a> 是一个静态网站生成器，基于 React 技术构建，编译成的是静态的 HTML css，支持 Markdown 语法。</li><li><a href="https://d.umijs.org/zh-CN">Dumi</a> 是一款为组件开发场景而生的文档工具，与 <a href="https://github.com/umijs/father">father</a> 一起为开发者提供一站式的组件开发体验，father 负责构建，而 dumi 负责组件开发及组件文档生成。</li></ul><h1 id="部署方案"><a href="#部署方案" class="headerlink" title="部署方案"></a>部署方案</h1><blockquote><p>当然部署方案有很多，在服务器不用自己搭建的的基础上，无非就是找到可以实现免费托管的云厂商进行托管前端静态资源，生成可供访问的域名。</p></blockquote><p>这里仅列出几种方案，供参考。</p><ul><li><a href="https://pages.github.com/">Github Pages</a></li><li><a href="https://vercel.com/">Vercel</a></li><li><a href="https://coding.net/">Coding</a></li><li>Serverless（无服务器，按量付费）<ul><li><a href="http://serverless-devs.com/">Serverless Devs 阿里云</a></li><li><a href="https://www.serverless.com/cn/">Serverless Framework 腾讯云</a></li></ul></li></ul><!-- - Serverless- [内容分发网络CDN](https://www.aliyun.com/product/cdn) + [对象存储OSS](https://www.aliyun.com/product/oss)- [阿里云函数计算FC](https://www.aliyun.com/product/fc) --><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><blockquote><p>上诉博客框架以及部署方案任选其一，下面仅以 <code>Hexo </code>  为例，做 <code>Github Pages</code> 部署方案的介绍，感兴趣可以自行了解其他框架的使用。</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="https://nodejs.org/en/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p><img src="https://hfscdn.vercel.app/blog/image/node-git-version.jpg" alt="iamge"></p><p>如图，如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往安装 <a href="#%E5%AE%89%E8%A3%85-Hexo">安装 Hexo</a>。</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="- 安装 Git"></a>- 安装 Git</h3><p>Windows：下载并安装<a href="https://git-scm.com/download/win">Git</a><br>Mac：使用 <a href="https://brew.sh/">Homebrew</a>, <a href="https://www.macports.org/">MacPorts</a> 或者下载<a href="https://sourceforge.net/projects/git-osx-installer/">安装程序</a>。<br>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code><br>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="- 安装 Node.js"></a>- 安装 Node.js</h3><p>Node.js 为大多数平台提供了官方的<a href="https://nodejs.org/en/download/">安装程序</a>。对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a>下载。</p><p>其它的安装方法：</p><p>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。<br>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="https://www.macports.org/">MacPorts</a> 安装。<br>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。<br>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a>。</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="- 安装 Hexo"></a>- 安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 <code>npm</code> 安装 <code>Hexo</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="- 初始化"></a>- 初始化</h3><p>安装 <code>Hexo</code> 完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt; &#x2F;&#x2F; 初始化，如 hexo init blog</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install &#x2F;&#x2F; 可选，hexo 初始化默认会自动安装相关依赖</span><br><span class="line">hexo server &#x2F;&#x2F; 本地启动</span><br></pre></td></tr></table></figure><p><img src="https://hfscdn.vercel.app/blog/image/hexo-server.jpg" alt="hexo"><br>本地启动后，出现上即启动成功，浏览器登录图示 <code>http://localhost:4000</code> 地址即可本地访问。</p><p>更多配置信息见 <a href="https://hexo.io/zh-cn/docs/">Hexo 配置</a></p><h2 id="部署（Github-Page）"><a href="#部署（Github-Page）" class="headerlink" title="部署（Github Page）"></a>部署（Github Page）</h2><blockquote><p>上面已经把静态页面搭建完毕，接下来只需把代码部署到指定云厂商托管即可，以下提供三种部署方案，仅供参考。</p></blockquote><h3 id="Github-创建-repository"><a href="#Github-创建-repository" class="headerlink" title="- Github 创建 repository"></a>- Github 创建 repository</h3><p>在本教程中，我们 将 <code>Hexo</code> 博客部署到 <code>GitHub Pages</code> 上。</p><ul><li><a href="https://github.com/new">新建</a>一个 repository。如果你希望你的站点能通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io，如我的 Github 用户名为<code>huangfushan</code>, repository 即 <code>huangfushan.github.io</code>。</li><li>默认情况下不应该 public 目录将不会被推送到 repository 中，你应该检查 .gitignore 文件中是否包含 public 一行，如果没有请加上。</li><li>首次使用 <code>Github</code> 可能需要<a href="https://github.com/settings/ssh/new">绑定 SSH Key 密匙</a>，若无密匙见 <a href="/2021/04/25/git/">生成 SSH Key 密匙</a></li></ul><h3 id="Hexo-部署到-Github-Page"><a href="#Hexo-部署到-Github-Page" class="headerlink" title="- Hexo 部署到 Github Page"></a>- Hexo 部署到 Github Page</h3><ul><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br></pre></td></tr></table></figure></li><li>修改配置 _config.yml<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; # https:&#x2F;&#x2F;github.com&#x2F;你的 GitHub 用户名&#x2F;你的 GitHub 用户名.github.io.git</span><br></pre></td></tr></table></figure></li><li>部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate &#x2F;&#x2F; 编译</span><br><span class="line">hexo deploy &#x2F;&#x2F; 部署</span><br></pre></td></tr></table></figure><img src="https://hfscdn.vercel.app/blog/image/hexo-deploy.jpg" alt="deploy"></li><li>访问 https://你的 GitHub 用户名.github.io，如 <a href="https://huangfushan.github.io/">https://huangfushan.github.io</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 指令</title>
      <link href="2021/04/25/git/"/>
      <url>2021/04/25/git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git-指令"><a href="#Git-指令" class="headerlink" title="Git 指令"></a>Git 指令</h1><h2 id="设置用户名与邮箱"><a href="#设置用户名与邮箱" class="headerlink" title="设置用户名与邮箱"></a>设置用户名与邮箱</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;name&lt;自己的用户名&gt;&quot;</span><br><span class="line">git config --global user.email &quot;email&lt;自己的邮箱&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="生成-SSH-Key-密匙"><a href="#生成-SSH-Key-密匙" class="headerlink" title="生成 SSH Key 密匙"></a>生成 SSH Key 密匙</h2><blockquote><p>cd 到 ~/.ssh 目录下查看是否存在 id_rsa.pub 文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ls</span><br><span class="line">  id_rsa id_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>若不存在，执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;emai&lt;自己的邮箱&gt;&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若涉及权限</span><br><span class="line">sudo ssh-keygen -t rsa -C &quot;emai&lt;自己的邮箱&gt;&quot; </span><br></pre></td></tr></table></figure><p>执行成功后执行 <code>cat ~/.ssh/id_rsa.pub</code>查看密匙，如下图。<br><img src="https://hfscdn.vercel.app/blog/image/image/image/ssh-key.jpg" alt="SSH KEY"></p><h2 id="绑定远程仓库"><a href="#绑定远程仓库" class="headerlink" title="绑定远程仓库"></a>绑定远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &quot;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.git&quot; &#x2F;&#x2F; 初次绑定</span><br><span class="line">git remote set-url origin &quot;new repository&quot; &#x2F;&#x2F; 修改远程仓库</span><br></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="- 创建分支"></a>- 创建分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="- 切换分支"></a>- 切换分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h4 id="拉取合并"><a href="#拉取合并" class="headerlink" title="- 拉取合并"></a>- 拉取合并</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin&#x2F;&lt;分支名&gt;</span><br><span class="line">或</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="- 添加暂存区"></a>- 添加暂存区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add . &#x2F;&#x2F; 添加所有到暂存区</span><br><span class="line">git add &lt;分支名&gt; &#x2F;&#x2F; 添加指定分支到暂存取</span><br></pre></td></tr></table></figure><h4 id="commit"><a href="#commit" class="headerlink" title="- commit"></a>- commit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交日志&quot; &#x2F;&#x2F; 仅暂存区代码 commit</span><br><span class="line">git commit -am &quot;&quot; &#x2F;&#x2F; 添加所有文件到暂存区，并 commit </span><br></pre></td></tr></table></figure><h4 id="提交远程"><a href="#提交远程" class="headerlink" title="- 提交远程"></a>- 提交远程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">&#x2F;&#x2F; 强制提交</span><br><span class="line">git push -f </span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="- 查看分支"></a>- 查看分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch  &#x2F;&#x2F; 查看本地</span><br><span class="line">git branch -a  &#x2F;&#x2F; 查看远程</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="- 删除分支"></a>- 删除分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt; &#x2F;&#x2F; 删除本地分支</span><br><span class="line">git branch -D &lt;分支名&gt; &#x2F;&#x2F; 强制删除本地分支</span><br><span class="line">git push origin -d &lt;分支名&gt; &#x2F;&#x2F; 删除远程</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;文件名&gt; &#x2F;&#x2F; 文件取消暂存区</span><br><span class="line">git reset HEAD &#x2F;&#x2F; 取消所有暂存取</span><br><span class="line">git reset --soft HEAD^ &#x2F;&#x2F; 撤销上一次 commit，并且可以重新 commit</span><br></pre></td></tr></table></figure><h3 id="本地暂存"><a href="#本地暂存" class="headerlink" title="本地暂存"></a>本地暂存</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;需要暂存的文件&gt; &#x2F;&#x2F; 添加需要暂存的文件</span><br><span class="line">git stash commit &quot;暂存日志&quot; &#x2F;&#x2F; commit </span><br><span class="line">git stash list &#x2F;&#x2F; 查看所有暂存的 commit 记录</span><br><span class="line">git stash pop &#x2F;&#x2F; 提取最新一条暂存记录，提取指定某条有点问题，暂时不知道怎么提取</span><br></pre></td></tr></table></figure><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1、会删除代码，commit 记录不保留</span><br><span class="line">git reset —-hard &lt;commit id&gt; &#x2F;&#x2F; 回滚到指定 commit</span><br><span class="line">git push -f &#x2F;&#x2F; 强制提交，远程仓库将回滚</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2、会覆盖代码，commit 记录保留</span><br><span class="line">git revert &lt;commit id&gt; &#x2F;&#x2F; 用新的 commit 来回滚之前的 commit</span><br></pre></td></tr></table></figure><h1 id="使用-gitignore-无效的解决方法【已托管在git上的文件，需要保持到本地仓库】"><a href="#使用-gitignore-无效的解决方法【已托管在git上的文件，需要保持到本地仓库】" class="headerlink" title="使用.gitignore 无效的解决方法【已托管在git上的文件，需要保持到本地仓库】"></a>使用.gitignore 无效的解决方法【已托管在git上的文件，需要保持到本地仓库】</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached . &#x2F;&#x2F; 所有文件</span><br><span class="line">git rm -r --cached &lt;文件名&gt; &#x2F;&#x2F; 指定文件</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
